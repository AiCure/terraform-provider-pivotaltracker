// Code generated by counterfeiter. DO NOT EDIT.
package ptfakes

import (
	"net/http"
	"sync"

	"github.com/xchapter7x/terraform-provider-pivotaltracker/pkg/pt"
)

type FakeClientCaller struct {
	DeleteAccountMemberStub        func(int, int) (*http.Response, error)
	deleteAccountMemberMutex       sync.RWMutex
	deleteAccountMemberArgsForCall []struct {
		arg1 int
		arg2 int
	}
	deleteAccountMemberReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteAccountMemberReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteProjectStub        func(int) (*http.Response, error)
	deleteProjectMutex       sync.RWMutex
	deleteProjectArgsForCall []struct {
		arg1 int
	}
	deleteProjectReturns struct {
		result1 *http.Response
		result2 error
	}
	deleteProjectReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	GetAccountMemberStub        func(int, int) (*pt.AccountMember, *http.Response, error)
	getAccountMemberMutex       sync.RWMutex
	getAccountMemberArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getAccountMemberReturns struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}
	getAccountMemberReturnsOnCall map[int]struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}
	GetProjectStub        func(int) (*pt.Project, *http.Response, error)
	getProjectMutex       sync.RWMutex
	getProjectArgsForCall []struct {
		arg1 int
	}
	getProjectReturns struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}
	getProjectReturnsOnCall map[int]struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}
	ListAccountMembersStub        func(int) ([]pt.AccountMember, *http.Response, error)
	listAccountMembersMutex       sync.RWMutex
	listAccountMembersArgsForCall []struct {
		arg1 int
	}
	listAccountMembersReturns struct {
		result1 []pt.AccountMember
		result2 *http.Response
		result3 error
	}
	listAccountMembersReturnsOnCall map[int]struct {
		result1 []pt.AccountMember
		result2 *http.Response
		result3 error
	}
	ListProjectsStub        func() ([]*pt.Project, *http.Response, error)
	listProjectsMutex       sync.RWMutex
	listProjectsArgsForCall []struct {
	}
	listProjectsReturns struct {
		result1 []*pt.Project
		result2 *http.Response
		result3 error
	}
	listProjectsReturnsOnCall map[int]struct {
		result1 []*pt.Project
		result2 *http.Response
		result3 error
	}
	NewAccountMemberStub        func(int, pt.AccountMemberRequest) (*pt.AccountMember, *http.Response, error)
	newAccountMemberMutex       sync.RWMutex
	newAccountMemberArgsForCall []struct {
		arg1 int
		arg2 pt.AccountMemberRequest
	}
	newAccountMemberReturns struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}
	newAccountMemberReturnsOnCall map[int]struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}
	NewProjectStub        func(pt.ProjectsRequest) (*pt.Project, *http.Response, error)
	newProjectMutex       sync.RWMutex
	newProjectArgsForCall []struct {
		arg1 pt.ProjectsRequest
	}
	newProjectReturns struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}
	newProjectReturnsOnCall map[int]struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}
	UpdateAccountMemberStub        func(int, int, pt.AccountMemberRequest) (*pt.AccountMember, *http.Response, error)
	updateAccountMemberMutex       sync.RWMutex
	updateAccountMemberArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 pt.AccountMemberRequest
	}
	updateAccountMemberReturns struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}
	updateAccountMemberReturnsOnCall map[int]struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}
	UpdateProjectStub        func(int, pt.ProjectRequest) (*pt.Project, *http.Response, error)
	updateProjectMutex       sync.RWMutex
	updateProjectArgsForCall []struct {
		arg1 int
		arg2 pt.ProjectRequest
	}
	updateProjectReturns struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}
	updateProjectReturnsOnCall map[int]struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClientCaller) DeleteAccountMember(arg1 int, arg2 int) (*http.Response, error) {
	fake.deleteAccountMemberMutex.Lock()
	ret, specificReturn := fake.deleteAccountMemberReturnsOnCall[len(fake.deleteAccountMemberArgsForCall)]
	fake.deleteAccountMemberArgsForCall = append(fake.deleteAccountMemberArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("DeleteAccountMember", []interface{}{arg1, arg2})
	fake.deleteAccountMemberMutex.Unlock()
	if fake.DeleteAccountMemberStub != nil {
		return fake.DeleteAccountMemberStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteAccountMemberReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientCaller) DeleteAccountMemberCallCount() int {
	fake.deleteAccountMemberMutex.RLock()
	defer fake.deleteAccountMemberMutex.RUnlock()
	return len(fake.deleteAccountMemberArgsForCall)
}

func (fake *FakeClientCaller) DeleteAccountMemberCalls(stub func(int, int) (*http.Response, error)) {
	fake.deleteAccountMemberMutex.Lock()
	defer fake.deleteAccountMemberMutex.Unlock()
	fake.DeleteAccountMemberStub = stub
}

func (fake *FakeClientCaller) DeleteAccountMemberArgsForCall(i int) (int, int) {
	fake.deleteAccountMemberMutex.RLock()
	defer fake.deleteAccountMemberMutex.RUnlock()
	argsForCall := fake.deleteAccountMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientCaller) DeleteAccountMemberReturns(result1 *http.Response, result2 error) {
	fake.deleteAccountMemberMutex.Lock()
	defer fake.deleteAccountMemberMutex.Unlock()
	fake.DeleteAccountMemberStub = nil
	fake.deleteAccountMemberReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClientCaller) DeleteAccountMemberReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteAccountMemberMutex.Lock()
	defer fake.deleteAccountMemberMutex.Unlock()
	fake.DeleteAccountMemberStub = nil
	if fake.deleteAccountMemberReturnsOnCall == nil {
		fake.deleteAccountMemberReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteAccountMemberReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClientCaller) DeleteProject(arg1 int) (*http.Response, error) {
	fake.deleteProjectMutex.Lock()
	ret, specificReturn := fake.deleteProjectReturnsOnCall[len(fake.deleteProjectArgsForCall)]
	fake.deleteProjectArgsForCall = append(fake.deleteProjectArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("DeleteProject", []interface{}{arg1})
	fake.deleteProjectMutex.Unlock()
	if fake.DeleteProjectStub != nil {
		return fake.DeleteProjectStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteProjectReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClientCaller) DeleteProjectCallCount() int {
	fake.deleteProjectMutex.RLock()
	defer fake.deleteProjectMutex.RUnlock()
	return len(fake.deleteProjectArgsForCall)
}

func (fake *FakeClientCaller) DeleteProjectCalls(stub func(int) (*http.Response, error)) {
	fake.deleteProjectMutex.Lock()
	defer fake.deleteProjectMutex.Unlock()
	fake.DeleteProjectStub = stub
}

func (fake *FakeClientCaller) DeleteProjectArgsForCall(i int) int {
	fake.deleteProjectMutex.RLock()
	defer fake.deleteProjectMutex.RUnlock()
	argsForCall := fake.deleteProjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientCaller) DeleteProjectReturns(result1 *http.Response, result2 error) {
	fake.deleteProjectMutex.Lock()
	defer fake.deleteProjectMutex.Unlock()
	fake.DeleteProjectStub = nil
	fake.deleteProjectReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClientCaller) DeleteProjectReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.deleteProjectMutex.Lock()
	defer fake.deleteProjectMutex.Unlock()
	fake.DeleteProjectStub = nil
	if fake.deleteProjectReturnsOnCall == nil {
		fake.deleteProjectReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.deleteProjectReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClientCaller) GetAccountMember(arg1 int, arg2 int) (*pt.AccountMember, *http.Response, error) {
	fake.getAccountMemberMutex.Lock()
	ret, specificReturn := fake.getAccountMemberReturnsOnCall[len(fake.getAccountMemberArgsForCall)]
	fake.getAccountMemberArgsForCall = append(fake.getAccountMemberArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("GetAccountMember", []interface{}{arg1, arg2})
	fake.getAccountMemberMutex.Unlock()
	if fake.GetAccountMemberStub != nil {
		return fake.GetAccountMemberStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getAccountMemberReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) GetAccountMemberCallCount() int {
	fake.getAccountMemberMutex.RLock()
	defer fake.getAccountMemberMutex.RUnlock()
	return len(fake.getAccountMemberArgsForCall)
}

func (fake *FakeClientCaller) GetAccountMemberCalls(stub func(int, int) (*pt.AccountMember, *http.Response, error)) {
	fake.getAccountMemberMutex.Lock()
	defer fake.getAccountMemberMutex.Unlock()
	fake.GetAccountMemberStub = stub
}

func (fake *FakeClientCaller) GetAccountMemberArgsForCall(i int) (int, int) {
	fake.getAccountMemberMutex.RLock()
	defer fake.getAccountMemberMutex.RUnlock()
	argsForCall := fake.getAccountMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientCaller) GetAccountMemberReturns(result1 *pt.AccountMember, result2 *http.Response, result3 error) {
	fake.getAccountMemberMutex.Lock()
	defer fake.getAccountMemberMutex.Unlock()
	fake.GetAccountMemberStub = nil
	fake.getAccountMemberReturns = struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) GetAccountMemberReturnsOnCall(i int, result1 *pt.AccountMember, result2 *http.Response, result3 error) {
	fake.getAccountMemberMutex.Lock()
	defer fake.getAccountMemberMutex.Unlock()
	fake.GetAccountMemberStub = nil
	if fake.getAccountMemberReturnsOnCall == nil {
		fake.getAccountMemberReturnsOnCall = make(map[int]struct {
			result1 *pt.AccountMember
			result2 *http.Response
			result3 error
		})
	}
	fake.getAccountMemberReturnsOnCall[i] = struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) GetProject(arg1 int) (*pt.Project, *http.Response, error) {
	fake.getProjectMutex.Lock()
	ret, specificReturn := fake.getProjectReturnsOnCall[len(fake.getProjectArgsForCall)]
	fake.getProjectArgsForCall = append(fake.getProjectArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetProject", []interface{}{arg1})
	fake.getProjectMutex.Unlock()
	if fake.GetProjectStub != nil {
		return fake.GetProjectStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.getProjectReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) GetProjectCallCount() int {
	fake.getProjectMutex.RLock()
	defer fake.getProjectMutex.RUnlock()
	return len(fake.getProjectArgsForCall)
}

func (fake *FakeClientCaller) GetProjectCalls(stub func(int) (*pt.Project, *http.Response, error)) {
	fake.getProjectMutex.Lock()
	defer fake.getProjectMutex.Unlock()
	fake.GetProjectStub = stub
}

func (fake *FakeClientCaller) GetProjectArgsForCall(i int) int {
	fake.getProjectMutex.RLock()
	defer fake.getProjectMutex.RUnlock()
	argsForCall := fake.getProjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientCaller) GetProjectReturns(result1 *pt.Project, result2 *http.Response, result3 error) {
	fake.getProjectMutex.Lock()
	defer fake.getProjectMutex.Unlock()
	fake.GetProjectStub = nil
	fake.getProjectReturns = struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) GetProjectReturnsOnCall(i int, result1 *pt.Project, result2 *http.Response, result3 error) {
	fake.getProjectMutex.Lock()
	defer fake.getProjectMutex.Unlock()
	fake.GetProjectStub = nil
	if fake.getProjectReturnsOnCall == nil {
		fake.getProjectReturnsOnCall = make(map[int]struct {
			result1 *pt.Project
			result2 *http.Response
			result3 error
		})
	}
	fake.getProjectReturnsOnCall[i] = struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) ListAccountMembers(arg1 int) ([]pt.AccountMember, *http.Response, error) {
	fake.listAccountMembersMutex.Lock()
	ret, specificReturn := fake.listAccountMembersReturnsOnCall[len(fake.listAccountMembersArgsForCall)]
	fake.listAccountMembersArgsForCall = append(fake.listAccountMembersArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("ListAccountMembers", []interface{}{arg1})
	fake.listAccountMembersMutex.Unlock()
	if fake.ListAccountMembersStub != nil {
		return fake.ListAccountMembersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.listAccountMembersReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) ListAccountMembersCallCount() int {
	fake.listAccountMembersMutex.RLock()
	defer fake.listAccountMembersMutex.RUnlock()
	return len(fake.listAccountMembersArgsForCall)
}

func (fake *FakeClientCaller) ListAccountMembersCalls(stub func(int) ([]pt.AccountMember, *http.Response, error)) {
	fake.listAccountMembersMutex.Lock()
	defer fake.listAccountMembersMutex.Unlock()
	fake.ListAccountMembersStub = stub
}

func (fake *FakeClientCaller) ListAccountMembersArgsForCall(i int) int {
	fake.listAccountMembersMutex.RLock()
	defer fake.listAccountMembersMutex.RUnlock()
	argsForCall := fake.listAccountMembersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientCaller) ListAccountMembersReturns(result1 []pt.AccountMember, result2 *http.Response, result3 error) {
	fake.listAccountMembersMutex.Lock()
	defer fake.listAccountMembersMutex.Unlock()
	fake.ListAccountMembersStub = nil
	fake.listAccountMembersReturns = struct {
		result1 []pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) ListAccountMembersReturnsOnCall(i int, result1 []pt.AccountMember, result2 *http.Response, result3 error) {
	fake.listAccountMembersMutex.Lock()
	defer fake.listAccountMembersMutex.Unlock()
	fake.ListAccountMembersStub = nil
	if fake.listAccountMembersReturnsOnCall == nil {
		fake.listAccountMembersReturnsOnCall = make(map[int]struct {
			result1 []pt.AccountMember
			result2 *http.Response
			result3 error
		})
	}
	fake.listAccountMembersReturnsOnCall[i] = struct {
		result1 []pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) ListProjects() ([]*pt.Project, *http.Response, error) {
	fake.listProjectsMutex.Lock()
	ret, specificReturn := fake.listProjectsReturnsOnCall[len(fake.listProjectsArgsForCall)]
	fake.listProjectsArgsForCall = append(fake.listProjectsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListProjects", []interface{}{})
	fake.listProjectsMutex.Unlock()
	if fake.ListProjectsStub != nil {
		return fake.ListProjectsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.listProjectsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) ListProjectsCallCount() int {
	fake.listProjectsMutex.RLock()
	defer fake.listProjectsMutex.RUnlock()
	return len(fake.listProjectsArgsForCall)
}

func (fake *FakeClientCaller) ListProjectsCalls(stub func() ([]*pt.Project, *http.Response, error)) {
	fake.listProjectsMutex.Lock()
	defer fake.listProjectsMutex.Unlock()
	fake.ListProjectsStub = stub
}

func (fake *FakeClientCaller) ListProjectsReturns(result1 []*pt.Project, result2 *http.Response, result3 error) {
	fake.listProjectsMutex.Lock()
	defer fake.listProjectsMutex.Unlock()
	fake.ListProjectsStub = nil
	fake.listProjectsReturns = struct {
		result1 []*pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) ListProjectsReturnsOnCall(i int, result1 []*pt.Project, result2 *http.Response, result3 error) {
	fake.listProjectsMutex.Lock()
	defer fake.listProjectsMutex.Unlock()
	fake.ListProjectsStub = nil
	if fake.listProjectsReturnsOnCall == nil {
		fake.listProjectsReturnsOnCall = make(map[int]struct {
			result1 []*pt.Project
			result2 *http.Response
			result3 error
		})
	}
	fake.listProjectsReturnsOnCall[i] = struct {
		result1 []*pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) NewAccountMember(arg1 int, arg2 pt.AccountMemberRequest) (*pt.AccountMember, *http.Response, error) {
	fake.newAccountMemberMutex.Lock()
	ret, specificReturn := fake.newAccountMemberReturnsOnCall[len(fake.newAccountMemberArgsForCall)]
	fake.newAccountMemberArgsForCall = append(fake.newAccountMemberArgsForCall, struct {
		arg1 int
		arg2 pt.AccountMemberRequest
	}{arg1, arg2})
	fake.recordInvocation("NewAccountMember", []interface{}{arg1, arg2})
	fake.newAccountMemberMutex.Unlock()
	if fake.NewAccountMemberStub != nil {
		return fake.NewAccountMemberStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.newAccountMemberReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) NewAccountMemberCallCount() int {
	fake.newAccountMemberMutex.RLock()
	defer fake.newAccountMemberMutex.RUnlock()
	return len(fake.newAccountMemberArgsForCall)
}

func (fake *FakeClientCaller) NewAccountMemberCalls(stub func(int, pt.AccountMemberRequest) (*pt.AccountMember, *http.Response, error)) {
	fake.newAccountMemberMutex.Lock()
	defer fake.newAccountMemberMutex.Unlock()
	fake.NewAccountMemberStub = stub
}

func (fake *FakeClientCaller) NewAccountMemberArgsForCall(i int) (int, pt.AccountMemberRequest) {
	fake.newAccountMemberMutex.RLock()
	defer fake.newAccountMemberMutex.RUnlock()
	argsForCall := fake.newAccountMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientCaller) NewAccountMemberReturns(result1 *pt.AccountMember, result2 *http.Response, result3 error) {
	fake.newAccountMemberMutex.Lock()
	defer fake.newAccountMemberMutex.Unlock()
	fake.NewAccountMemberStub = nil
	fake.newAccountMemberReturns = struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) NewAccountMemberReturnsOnCall(i int, result1 *pt.AccountMember, result2 *http.Response, result3 error) {
	fake.newAccountMemberMutex.Lock()
	defer fake.newAccountMemberMutex.Unlock()
	fake.NewAccountMemberStub = nil
	if fake.newAccountMemberReturnsOnCall == nil {
		fake.newAccountMemberReturnsOnCall = make(map[int]struct {
			result1 *pt.AccountMember
			result2 *http.Response
			result3 error
		})
	}
	fake.newAccountMemberReturnsOnCall[i] = struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) NewProject(arg1 pt.ProjectsRequest) (*pt.Project, *http.Response, error) {
	fake.newProjectMutex.Lock()
	ret, specificReturn := fake.newProjectReturnsOnCall[len(fake.newProjectArgsForCall)]
	fake.newProjectArgsForCall = append(fake.newProjectArgsForCall, struct {
		arg1 pt.ProjectsRequest
	}{arg1})
	fake.recordInvocation("NewProject", []interface{}{arg1})
	fake.newProjectMutex.Unlock()
	if fake.NewProjectStub != nil {
		return fake.NewProjectStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.newProjectReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) NewProjectCallCount() int {
	fake.newProjectMutex.RLock()
	defer fake.newProjectMutex.RUnlock()
	return len(fake.newProjectArgsForCall)
}

func (fake *FakeClientCaller) NewProjectCalls(stub func(pt.ProjectsRequest) (*pt.Project, *http.Response, error)) {
	fake.newProjectMutex.Lock()
	defer fake.newProjectMutex.Unlock()
	fake.NewProjectStub = stub
}

func (fake *FakeClientCaller) NewProjectArgsForCall(i int) pt.ProjectsRequest {
	fake.newProjectMutex.RLock()
	defer fake.newProjectMutex.RUnlock()
	argsForCall := fake.newProjectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClientCaller) NewProjectReturns(result1 *pt.Project, result2 *http.Response, result3 error) {
	fake.newProjectMutex.Lock()
	defer fake.newProjectMutex.Unlock()
	fake.NewProjectStub = nil
	fake.newProjectReturns = struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) NewProjectReturnsOnCall(i int, result1 *pt.Project, result2 *http.Response, result3 error) {
	fake.newProjectMutex.Lock()
	defer fake.newProjectMutex.Unlock()
	fake.NewProjectStub = nil
	if fake.newProjectReturnsOnCall == nil {
		fake.newProjectReturnsOnCall = make(map[int]struct {
			result1 *pt.Project
			result2 *http.Response
			result3 error
		})
	}
	fake.newProjectReturnsOnCall[i] = struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) UpdateAccountMember(arg1 int, arg2 int, arg3 pt.AccountMemberRequest) (*pt.AccountMember, *http.Response, error) {
	fake.updateAccountMemberMutex.Lock()
	ret, specificReturn := fake.updateAccountMemberReturnsOnCall[len(fake.updateAccountMemberArgsForCall)]
	fake.updateAccountMemberArgsForCall = append(fake.updateAccountMemberArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 pt.AccountMemberRequest
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateAccountMember", []interface{}{arg1, arg2, arg3})
	fake.updateAccountMemberMutex.Unlock()
	if fake.UpdateAccountMemberStub != nil {
		return fake.UpdateAccountMemberStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.updateAccountMemberReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) UpdateAccountMemberCallCount() int {
	fake.updateAccountMemberMutex.RLock()
	defer fake.updateAccountMemberMutex.RUnlock()
	return len(fake.updateAccountMemberArgsForCall)
}

func (fake *FakeClientCaller) UpdateAccountMemberCalls(stub func(int, int, pt.AccountMemberRequest) (*pt.AccountMember, *http.Response, error)) {
	fake.updateAccountMemberMutex.Lock()
	defer fake.updateAccountMemberMutex.Unlock()
	fake.UpdateAccountMemberStub = stub
}

func (fake *FakeClientCaller) UpdateAccountMemberArgsForCall(i int) (int, int, pt.AccountMemberRequest) {
	fake.updateAccountMemberMutex.RLock()
	defer fake.updateAccountMemberMutex.RUnlock()
	argsForCall := fake.updateAccountMemberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClientCaller) UpdateAccountMemberReturns(result1 *pt.AccountMember, result2 *http.Response, result3 error) {
	fake.updateAccountMemberMutex.Lock()
	defer fake.updateAccountMemberMutex.Unlock()
	fake.UpdateAccountMemberStub = nil
	fake.updateAccountMemberReturns = struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) UpdateAccountMemberReturnsOnCall(i int, result1 *pt.AccountMember, result2 *http.Response, result3 error) {
	fake.updateAccountMemberMutex.Lock()
	defer fake.updateAccountMemberMutex.Unlock()
	fake.UpdateAccountMemberStub = nil
	if fake.updateAccountMemberReturnsOnCall == nil {
		fake.updateAccountMemberReturnsOnCall = make(map[int]struct {
			result1 *pt.AccountMember
			result2 *http.Response
			result3 error
		})
	}
	fake.updateAccountMemberReturnsOnCall[i] = struct {
		result1 *pt.AccountMember
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) UpdateProject(arg1 int, arg2 pt.ProjectRequest) (*pt.Project, *http.Response, error) {
	fake.updateProjectMutex.Lock()
	ret, specificReturn := fake.updateProjectReturnsOnCall[len(fake.updateProjectArgsForCall)]
	fake.updateProjectArgsForCall = append(fake.updateProjectArgsForCall, struct {
		arg1 int
		arg2 pt.ProjectRequest
	}{arg1, arg2})
	fake.recordInvocation("UpdateProject", []interface{}{arg1, arg2})
	fake.updateProjectMutex.Unlock()
	if fake.UpdateProjectStub != nil {
		return fake.UpdateProjectStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.updateProjectReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClientCaller) UpdateProjectCallCount() int {
	fake.updateProjectMutex.RLock()
	defer fake.updateProjectMutex.RUnlock()
	return len(fake.updateProjectArgsForCall)
}

func (fake *FakeClientCaller) UpdateProjectCalls(stub func(int, pt.ProjectRequest) (*pt.Project, *http.Response, error)) {
	fake.updateProjectMutex.Lock()
	defer fake.updateProjectMutex.Unlock()
	fake.UpdateProjectStub = stub
}

func (fake *FakeClientCaller) UpdateProjectArgsForCall(i int) (int, pt.ProjectRequest) {
	fake.updateProjectMutex.RLock()
	defer fake.updateProjectMutex.RUnlock()
	argsForCall := fake.updateProjectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClientCaller) UpdateProjectReturns(result1 *pt.Project, result2 *http.Response, result3 error) {
	fake.updateProjectMutex.Lock()
	defer fake.updateProjectMutex.Unlock()
	fake.UpdateProjectStub = nil
	fake.updateProjectReturns = struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) UpdateProjectReturnsOnCall(i int, result1 *pt.Project, result2 *http.Response, result3 error) {
	fake.updateProjectMutex.Lock()
	defer fake.updateProjectMutex.Unlock()
	fake.UpdateProjectStub = nil
	if fake.updateProjectReturnsOnCall == nil {
		fake.updateProjectReturnsOnCall = make(map[int]struct {
			result1 *pt.Project
			result2 *http.Response
			result3 error
		})
	}
	fake.updateProjectReturnsOnCall[i] = struct {
		result1 *pt.Project
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClientCaller) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteAccountMemberMutex.RLock()
	defer fake.deleteAccountMemberMutex.RUnlock()
	fake.deleteProjectMutex.RLock()
	defer fake.deleteProjectMutex.RUnlock()
	fake.getAccountMemberMutex.RLock()
	defer fake.getAccountMemberMutex.RUnlock()
	fake.getProjectMutex.RLock()
	defer fake.getProjectMutex.RUnlock()
	fake.listAccountMembersMutex.RLock()
	defer fake.listAccountMembersMutex.RUnlock()
	fake.listProjectsMutex.RLock()
	defer fake.listProjectsMutex.RUnlock()
	fake.newAccountMemberMutex.RLock()
	defer fake.newAccountMemberMutex.RUnlock()
	fake.newProjectMutex.RLock()
	defer fake.newProjectMutex.RUnlock()
	fake.updateAccountMemberMutex.RLock()
	defer fake.updateAccountMemberMutex.RUnlock()
	fake.updateProjectMutex.RLock()
	defer fake.updateProjectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClientCaller) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pt.ClientCaller = new(FakeClientCaller)
